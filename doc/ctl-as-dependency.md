# Adding CTL as a Dependency

CTL can be imported as an additional dependency into a Purescript project built with Spago (i.e. by listing the project in your `packages.dhall`). Running CTL contracts requires several [runtime dependencies](./runtime.md) as well.

**Table of Contents**

- [Caveats](#caveats)
- [Using the CTL overlay](#using-the-ctl-overlay)
- [Upgrading CTL](#upgrading-ctl)

## Caveats

The following caveats alway applies when using CTL from your project:

1. Only bundling with Webpack is supported (this is due to our internal dependency on `cardano-serialization-lib` which uses WASM; only Webpack is reliably capable of bundling this properly)
2. The environment variable `BROWSER_RUNTIME` determines which version of `cardano-serialization-lib` is loaded by CTL, so you must use it as well (i.e. set it to `1` for the browser; leave it unset for NodeJS)

## Using the CTL overlay

CTL exposes an `overlay` from its flake. You can use this in the Nix setup of your own project to use the same setup as we do, e.g. the same packages and PS builders. Here is an example `flake.nix` that takes CTL as a dependency:

```nix
{
  inputs = {
    cardano-transaction-lib = {
      type = "github";
      owner = "Plutonomicon";
      repo = "cardano-transaction-lib";
      # NOTE
      # This should match the same revision as the one in your `packages.dhall` to ensure
      # the greatest compatibility
      rev = "a5539ab89853393b11f6893485a89251f51d17ef";
    };

    # To use the same version of `nixpkgs` as we do
    nixpkgs.follows = "cardano-transaction-lib/nixpkgs";
  };

  outputs = { self, cardano-transaction-lib, ... }:
    # some boilerplate
    let
      perSystem = nixpkgs.lib.genAttrs [
        "x86_64-linux"
        "x86_64-darwin"
        "aarch64-linux"
        "aarch64-darwin"
      ];
      # generate `pkgs` with the CTL overlay applied. This gives you access to
      # various additional packages, using the same versions of CTL, including:
      #   - all of `easy-purescript-nix`
      #   - Ogmios and `ogmios-datum-cache`
      #   - `cardano-cli`
      nixpkgsFor = system: import nixpkgs {
        inherit system;
        overlays = [ cardano-transaction-lib.overlay ];
      };

      # The overlay also include several tools for generating a PS project
      # using the same approach as CTL, under `purescriptProject`
      psProjectFor = system:
        let
          # Will be used to generate derivation names
          projectName = "your-project";

          pkgs = nixpkgsFor system;
          # This is the root of the project. Typically, this would be `self`
          # for flakes-based projects
          #
          # You may also want to filter this to avoid bloat or unecessary
          # rebuilds when copying the source into derivations. Make sure to
          # use `builtins.path` with an explicit `name`, as `builtins.filterSource`
          # will still trigger rebuilds when using flakes, even when only a
          # filtered path is modified
          src = builtins.path {
            path = self;
            name = "${projectName}-src";
            filter = path: ftype:
              # filter out certain files, e.g. markdown
              !(pkgs.lib.hasSuffix ".md" path)
              # or entire directories
              && !(ftype == "directory" && builtins.elem
                (baseNameOf path) [ "doc" ]
              );
          };
        in
        # `purescriptProject` takes the `src` argument and compiles all of the
        # Purescipt source files contained within. There is no way to define
        # individual components using spago, so all of the `sources` defined
        # in your `spago.dhall` will always be compiled. Then this compiled
        # project is used in `bundlePursProject` and `runPursTest`, examples
        # of which are shown below
        pkgs.purescriptProject {
          inherit pkgs src projectName;

          # These paths can usually be easily derived from the `src` argument
          # above. However, it is *strongly* recommended to pass them in
          # explicitly, as it helps avoid rebuilding the generated `node_modules`
          # for your project
          packageJson = ./package.json;
          packageLock = ./package-lock.json;

          # Optional arg to override the version of `nodejs` used, defaulting to
          # the version used by CTL itself. This will be used throughout
          # `purescriptProject`
          #
          # Note that the version of `purs` is not configurable, as CTL
          # will currently break with any other version (it uses 0.14.5
          # internally)
          nodejs = pkgs.nodejs-14_x;

          # Also optional; the path to the packages generated by `spago2nix`,
          # defaulting to:
          spagoPackages = "${src}/spago-packages.nix";

          # If warnings generated from compilation fo project source files will
          # trigger a build error
          strictComp = true;

          # Warnings from `purs` to silence during compilation
          censorCodes = [ "UserDefinedWarning" ];

          # The optional `shell` lets you configure the `devShell` that is
          # generated by `purescriptProject`
          #
          # All of the attrs below are entirely optional (shown here with
          # their default values)
          shell = {
            # Extra packages to include in the shell environment. By default
            # a common version of `nodejs`, `purs`, `spago`, and more are
            # included
            packages = [ ];

            # This will be appended to the `shellHook` that runs. By default,
            # the `shellHook` loads generated `node_modules` and exports a
            # modified `NODE_PATH` and `PATH`
            shellHook = "";

            # The same as `pkgs.mkShell.inputsFrom`
            inputsFrom = [ ];

            # Which formatter to be made available, `purty` is another option
            formatter = "purs-tidy";

            # If `purescript-language-server` should be included in the shell
            pursls = true;
          };
        };

    in
    {
      packages = perSystem (system: {
        # `bundlePursProject` creates a JS bundle with webpack
        your-project-bundle = (psProjectFor system).bundlePursProject {
          # All of the following are optional and show with default values:
          #
          # The main Purscript module entrypoint
          main = "Main";
          # The JS entrypoint (must correspond to the one listed in the
          # webpack config), relative to the `src`
          entrypoint = "index.js";
          # The HTML template to render the bundle to (must correspond to
          # the template listed in the webpack config)
          htmlTemplate = "index.html";
          # If this should be bundled for the browser
          browserRuntime = true;
          # The path to the webpack config to use
          webpackConfig = "webpack.config.js";
          # The module that `spago bundle-module` should write to (must
          # match the one that is imported in your JS entrypoint). Is
          # relative to the `src` argument provided to `purescriptProject`
          bundledModuleName = "output.js";
        };
      });

      checks = perSystem (system: {
        # Build and run a test, also useful for CI
        your-project = (psProjectFor system).runPursTest {
          # Optional arg, the default value is:
          testMain = "Test.Main";
        };
      });

      # This corresponds to the `shell` argument given above
      devShell = perSystem (system: (psProjectFor system).devShell);
    };
}
```

We have recenly set up a small scaffolding repository for projects wishing to adopt CTL: https://github.com/mlabs-haskell/ctl-scaffold. More documentation and resources will be added soon to the repo

## Upgrading CTL

Unfortunately, the process of upgrading CTL is fairly involved. This is in part due to the complexity of the project and in part due to features inherent to Spago's approach to dependency management. The following assumes that you are using a project based on Nix flakes and using our overlay as outlined above.

Make sure to perform **all** of the following steps, otherwise you **will** encounter difficult-to-debug issues:

1. **Update your flake input**
  - Update the `rev` you're using for CTL in your flake `inputs`
    - **Note**: Nix might throw an error about CTL following a "non-existent input" after doing this. The best way to solve this is to upgrade the version of Nix that you're using. Otherwise, `nix flake lock --update-input <NAME>`, where `NAME` is the one you're using for CTL in your `inputs`, should solve this
2. **Update your Purescript dependencies**
  - Update the CTL `version` in your `packages.dhall`. Make sure that this is the exact same revision as in your flake inputs
  - Possibly update the `dependencies` section for CTL in your `packages.dhall`
    - You can find a list of CTL's dependencies in our own `spago.dhall` (but make sure to check at the correct revision)
    - You might also need to add new transitive git dependencies if CTL has added any to its own direct dependencies (i.e. you need to copy the matching stanzas from CTL's `packages.dhall` to your own; these are contained in the `additions` record in CTL's `packages.dhall`)
      - For example, if the following package `foo` is added to CTL's `additions` (in `packages.dhall`) between your old revision and the one you're upgrading to:
        ```dhall

        let additions =
              { foo =
                { dependencies =
                  [ "bar"
                  , "baz"
                  ]
                }
              , repo = "https://github.com/quux/foo.git"
              , version = "0000000000000000000000000000000000000000"
              -- ...
              }
        ```
        You also need to add the same package, identically, to your own `packages.dhall`, otherwise the compiler will not be able to find it
  - Run `spago2nix generate` and make sure to stage and commit the resulting `spago-packages.nix` if it has changed
3. **Update your JS dependencies**
  - If CTL has added any JS dependencies, these will also need to be added to your own `package.json` 
  - Similarly, if any of CTL's JS dependencies have changed versions, you will need to use the **exact** same version in your own `package.json`
  - That is, avoid using the `~` or `^` prefixes (e.g use versions like `"1.6.51"` instead of `"^1.6.51"`)
  - If you're using a `package-lock.json` (which is _highly_ recommended), you can update the lockfile with `npm i --package-lock-only`
